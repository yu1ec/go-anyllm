# é˜²æ­¢è¿‡æ—©é€€å‡ºç¤ºä¾‹

## é—®é¢˜åœºæ™¯

åœ¨æµæ¨¡å¼ä¸‹ï¼Œå¯èƒ½é‡åˆ°ä»¥ä¸‹æƒ…å†µï¼š
1. æµå·²ç»ç»“æŸï¼ˆ`FinishReason != ""`ï¼‰
2. ä½†å·¥å…·è°ƒç”¨çš„JSONå‚æ•°è¿˜æ²¡æœ‰å®Œå…¨ä¼ è¾“å®Œæˆ
3. å¦‚æœæ­¤æ—¶é€€å‡ºï¼Œä¼šä¸¢å¤±éƒ¨åˆ†å·¥å…·è°ƒç”¨

## è§£å†³æ–¹æ¡ˆ

ä½¿ç”¨ `HasPendingToolCalls()` æ–¹æ³•æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å¾…å®Œæˆçš„å·¥å…·è°ƒç”¨ã€‚

## ä»£ç ç¤ºä¾‹

### âŒ é”™è¯¯çš„åšæ³•ï¼ˆå¯èƒ½è¿‡æ—©é€€å‡ºï¼‰

```go
func handleStreamWrong(stream response.StreamReader) error {
    for stream.Next() {
        chunk := stream.Current()
        // ... å¤„ç†é€»è¾‘ ...
        
        // é”™è¯¯ï¼šä¸€æ—¦æ”¶åˆ°FinishReasonå°±ç«‹å³é€€å‡º
        if choice.FinishReason != "" {
            fmt.Println("æµç»“æŸï¼Œé€€å‡º")
            break // å¯èƒ½ä¸¢å¤±æ­£åœ¨ç”Ÿæˆçš„å·¥å…·è°ƒç”¨
        }
    }
    return stream.Error()
}
```

### âœ… æ­£ç¡®çš„åšæ³•ï¼ˆä½¿ç”¨HasPendingToolCallsï¼‰

```go
func handleStreamCorrect(stream response.StreamReader) error {
    accumulator := tools.NewStreamingToolCallAccumulator()
    registry := tools.NewFunctionRegistry()
    registry.Register("get_weather", &WeatherHandler{})
    
    for stream.Next() {
        chunk := stream.Current()
        if chunk == nil || len(chunk.Choices) == 0 {
            continue
        }
        
        choice := chunk.Choices[0]
        if choice.Delta == nil {
            continue
        }
        
        // å¤„ç†å¸¸è§„å†…å®¹
        if choice.Delta.Content != "" {
            fmt.Print(choice.Delta.Content)
        }
        
        // å¤„ç†å·¥å…·è°ƒç”¨
        if len(choice.Delta.ToolCalls) > 0 {
            accumulator.ProcessDelta(choice.Delta.ToolCalls)
            
            // æ‰§è¡Œå·²å®Œæˆçš„å·¥å…·è°ƒç”¨
            completed := accumulator.GetCompletedToolCalls()
            for _, toolCall := range completed {
                result := registry.Handle(toolCall)
                fmt.Printf("\nå·¥å…·æ‰§è¡Œç»“æœ: %s\n", result.Content)
            }
            accumulator.ClearCompleted()
        }
        
        // æ­£ç¡®ï¼šæ£€æŸ¥å®ŒæˆçŠ¶æ€æ—¶è€ƒè™‘å¾…å®Œæˆçš„å·¥å…·è°ƒç”¨
        if choice.FinishReason != "" {
            fmt.Printf("\næµç»“æŸä¿¡å·æ”¶åˆ°: %s\n", choice.FinishReason)
            
            // å…³é”®æ£€æŸ¥ï¼šæ˜¯å¦è¿˜æœ‰å·¥å…·è°ƒç”¨æ­£åœ¨ç”Ÿæˆä¸­
            if accumulator.HasPendingToolCalls() {
                pendingCount := accumulator.GetPendingCount()
                fmt.Printf("[ç­‰å¾…] ä»æœ‰ %d ä¸ªå·¥å…·è°ƒç”¨æ­£åœ¨ç”Ÿæˆä¸­ï¼Œç»§ç»­ç­‰å¾…...\n", pendingCount)
                
                // æ˜¾ç¤ºå¾…å®Œæˆçš„å·¥å…·è°ƒç”¨çŠ¶æ€ï¼ˆå¯é€‰ï¼Œç”¨äºè°ƒè¯•ï¼‰
                pending := accumulator.GetPendingToolCalls()
                for id, args := range pending {
                    fmt.Printf("  - å·¥å…·è°ƒç”¨ %s: %q\n", id, args)
                }
                
                continue // ä¸è¦é€€å‡ºï¼Œç»§ç»­å¤„ç†
            }
            
            fmt.Println("æ‰€æœ‰å·¥å…·è°ƒç”¨å·²å®Œæˆï¼Œå®‰å…¨é€€å‡º")
            break
        }
    }
    
    return stream.Error()
}
```

### ğŸ”§ å¸¦è¶…æ—¶æœºåˆ¶çš„ç‰ˆæœ¬

```go
func handleStreamWithTimeout(stream response.StreamReader, timeout time.Duration) error {
    accumulator := tools.NewStreamingToolCallAccumulator()
    registry := tools.NewFunctionRegistry()
    registry.Register("get_weather", &WeatherHandler{})
    
    var finishTime time.Time
    streamFinished := false
    
    for stream.Next() {
        chunk := stream.Current()
        if chunk == nil || len(chunk.Choices) == 0 {
            continue
        }
        
        choice := chunk.Choices[0]
        if choice.Delta == nil {
            continue
        }
        
        // å¤„ç†å·¥å…·è°ƒç”¨
        if len(choice.Delta.ToolCalls) > 0 {
            accumulator.ProcessDelta(choice.Delta.ToolCalls)
            
            completed := accumulator.GetCompletedToolCalls()
            for _, toolCall := range completed {
                result := registry.Handle(toolCall)
                fmt.Printf("å·¥å…·æ‰§è¡Œ: %s -> %s\n", toolCall.Function.Name, result.Content)
            }
            accumulator.ClearCompleted()
        }
        
        if choice.FinishReason != "" && !streamFinished {
            streamFinished = true
            finishTime = time.Now()
            fmt.Printf("æµç»“æŸ: %s\n", choice.FinishReason)
        }
        
        // å¦‚æœæµå·²ç»“æŸï¼Œæ£€æŸ¥å·¥å…·è°ƒç”¨çŠ¶æ€
        if streamFinished {
            if accumulator.HasPendingToolCalls() {
                elapsed := time.Since(finishTime)
                pendingCount := accumulator.GetPendingCount()
                
                fmt.Printf("[ç­‰å¾… %.1fs] %d ä¸ªå·¥å…·è°ƒç”¨æœªå®Œæˆ\n", 
                          elapsed.Seconds(), pendingCount)
                
                // è¶…æ—¶æ£€æŸ¥
                if elapsed > timeout {
                    fmt.Printf("[è¶…æ—¶] ç­‰å¾…å·¥å…·è°ƒç”¨å®Œæˆè¶…è¿‡ %.1fsï¼Œå¼ºåˆ¶é€€å‡º\n", 
                              timeout.Seconds())
                    
                    // æ˜¾ç¤ºæœªå®Œæˆçš„å·¥å…·è°ƒç”¨
                    pending := accumulator.GetPendingToolCalls()
                    for id, args := range pending {
                        fmt.Printf("  æœªå®Œæˆ: %s -> %q\n", id, args)
                    }
                    break
                }
                continue
            }
            
            fmt.Println("æ‰€æœ‰å·¥å…·è°ƒç”¨å®Œæˆï¼Œé€€å‡º")
            break
        }
    }
    
    return stream.Error()
}
```

## ä½¿ç”¨æ–¹æ³•

```go
func main() {
    // åŸºæœ¬ç”¨æ³•
    err := handleStreamCorrect(stream)
    
    // å¸¦è¶…æ—¶çš„ç”¨æ³•
    err := handleStreamWithTimeout(stream, 30*time.Second)
    
    if err != nil {
        log.Fatal(err)
    }
}
```

## å…³é”®è¦ç‚¹

1. **å§‹ç»ˆæ£€æŸ¥ `HasPendingToolCalls()`**ï¼šåœ¨æ”¶åˆ° `FinishReason` æ—¶ä¸è¦ç«‹å³é€€å‡º
2. **ä½¿ç”¨è¶…æ—¶æœºåˆ¶**ï¼šé˜²æ­¢æ— é™ç­‰å¾…
3. **ç›‘æ§è¿›åº¦**ï¼šä½¿ç”¨ `GetPendingCount()` æ˜¾ç¤ºç­‰å¾…çŠ¶æ€
4. **è°ƒè¯•æ”¯æŒ**ï¼šä½¿ç”¨ `GetPendingToolCalls()` æŸ¥çœ‹å…·ä½“çš„å¾…å®Œæˆå·¥å…·è°ƒç”¨

è¿™æ ·å¯ä»¥ç¡®ä¿æ‰€æœ‰å·¥å…·è°ƒç”¨éƒ½èƒ½æ­£ç¡®å®Œæˆï¼Œä¸ä¼šå› ä¸ºè¿‡æ—©é€€å‡ºè€Œä¸¢å¤±æ•°æ®ã€‚ 